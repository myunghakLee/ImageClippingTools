# -*- coding: utf-8 -*-
"""DataPreprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j7K4uQix4hVy2AkPXKTNY-fYSQQJRDDF
"""

import argparse
import json
import cv2
import json
from PIL import Image
import random
import random

parser = argparse.ArgumentParser(description='PreProcessing')
parser.add_argument('--image_size', type=int, default=3000)
parser.add_argument('--crop_size', type=int, default=600, choices=[300, 500, 600])
parser.add_argument('--overlap_size', type=int, default=300, choices=[100, 200, 300])
parser.add_argument('--save_path', type=str, default='prac')
parser.add_argument('--image_path', type=str, default='images_original')
parser.add_argument('--json_file', type=str , default='labels_original.json')
parser.add_argument('--noise_include_ratio', type=float, default=0.05)
parser.add_argument('--print_frequency', type=int, default=50)
args = parser.parse_args()
crop_size = args.crop_size
overlap_size = args.overlap_size
image_size = args.image_size
save_path = args.save_path +'/'
image_path = args.image_path + '/'
Noise_include_ratio = args.noise_include_ratio
PrintFrequency = args.print_frequency

f = open(save_path + "option.txt", 'w')
option_data = ""
option_data += "crop_size : " + str(crop_size) + '\n'
option_data += "overlap_size : " + str(overlap_size) + '\n'
option_data += "save_path : " + str(save_path) + '\n'
option_data += "image_path : " + str(image_path) + '\n'
option_data += "Noise_include_ratio : " + str(Noise_include_ratio) + '\n'
option_data += "Noise_include_ratio : " + str(Noise_include_ratio) + '\n'
option_data += "PrintFrequency : " + str(PrintFrequency) + '\n'
f.write(option_data)
f.close()

def Is_exceed(bbox, temp_image):   # temp_image = [xmin, ymin, xmax, ymax]
  boxs = []
  exceed = []

  for i, box in enumerate(bbox):
    Xmin = min(box[0],box[2],box[4],box[6])
    Xmax = min(box[0],box[2],box[4],box[6])
    Ymin = min(box[1],box[3],box[5],box[7])
    Ymax = min(box[1],box[3],box[5],box[7])
    # if (Xmax < temp_image[0] or Xmin > temp_image[2] or 
    #     Ymax < temp_image[1] or Ymin > temp_image[3]):
    #   not_excced[i] = False
    #   boxs.append("")
    if (temp_image[0] < Xmin < temp_image[2] and temp_image[0] < Xmax < temp_image[2] and
                                                    temp_image[1] < Ymin < temp_image[3] and 
                                                    temp_image[1] < Ymax < temp_image[3]):      #bounding box가 완전히 사진 안에 들어가는 경우
      exceed.append(False) 
      
      boxs.append([box[0] - temp_image[0] , box[1] - temp_image[1],
                   box[2] - temp_image[0] , box[3] - temp_image[1],
                   box[4] - temp_image[0] , box[5] - temp_image[1],
                   box[6] - temp_image[0] , box[7] - temp_image[1]])
    else:
      exceed.append(True) 
      boxs.append([None])

  Info = {}
  Info['IsExceed'] = exceed
  Info['Box'] = boxs
  return Info



image_dic = {}
with open(args.json_file) as json_file:
  json_datas = json.load(json_file)
  for json_data in json_datas['features']:
    image_id = json_data['properties']['image_id']
    box_position = json_data['properties']['bounds_imcoords']
    box_position = box_position.split(',')
    box_position = [float(i) for i in box_position]
    try:
      image_dic[image_id].append(box_position)
    except KeyError:
      image_dic[image_id] = []
      image_dic[image_id].append(box_position)


for i, key in enumerate(image_dic.keys()):
  if (i+1) % PrintFrequency == 0:
      print("num : " + i + "complete")
  
  if i >10:
    break
  img = Image.open(image_path + key)
  minX, minY, maxX, maxY = 0, 0, crop_size, crop_size
  while True:
    if maxY > 3000:
      break
    if maxX > 3000:
      minX = 0
      maxX = crop_size
      maxY += overlap_size
      minY += overlap_size
    else:
      ExceedInfo = Is_exceed(image_dic[key], [minX, minY, maxX, maxY])
      for i in range(len(ExceedInfo['IsExceed'])):
        if(not ExceedInfo['IsExceed'][i] or random.random() < Noise_include_ratio):
          area = (minX, minY, maxX, maxY)
          cropped_img = img.crop(area)
          path = save_path + str(key.split('.')[0]) + "_" + str(minY) + "_" + str(minX) +"_" + str(maxY) + "_" + str(maxX) + ".png"
          cropped_img.save(path)

        maxX+=overlap_size
        minX+=overlap_size


